# Program

For you, a software user, it is only necessary to know that a program is something that can be executed, despite the proper definition.

## Random access memory

In every computer, there is a hardware component called **random access memory** (**RAM**). The name indicates that randomly accessing different parts of the memory takes the same amount of time, in contrary to other types of storage. It is also very fast.

Generally, RAM is the only device that is readily accessible by the CPU, so the running state of programs has to be kept in RAM.

RAM is **volatile**. All data in RAM is lost once power is lost.

## Binary program

Binary instructions are the only thing that computers can execute directly. These binary instructions are known to be in **machine language**.

However, a given machine only accepts some machine languages, not all the ones that exist in the world. These pecuilarities are standardized into **instruction sets**, sets of instructions that the machine is able to execute, for example, x86 or arm are different instruction sets. A machineâ€™s instruction sets must contain all the instructions used in the program for the program to run correctly. Luckily, when dealing with recent processors, we only need to match the major **architecture** of the CPU to run the program correctly, because this is enough to match to the correct instruction sets.

Machine code runs at a very low level. It instructs the CPU directly. At this level, data is retreived by memory addresses, and the orderly execution of software is accomplished by correctly maintaining parts of memory. For example, machine codes may add or subtract numbers, compare values, access CPU registers, call interruptions or do some basic flow controls.

## To and from binary programs

Machine code is too low level, so it is hard for people to write and maintain. Therefore, most high-level programs are not written in machine codes. Instead, we write in one of the **high-level languages** (for example, C), and use a **compiler** to compile high-level **source codes** into low-level machine codes and generate binaries. These source codes are easier for human to read and maintain than machine codes. For example, a C language programmer can easily store numbers into the memory and add or subtract them in a single line of code, but they have to operate registers themselves if they use machine codes. Most compilers can also **optimize** programs, changing some algorithms for efficiency but without changing the way the program interacts.

The reverse of this process is possible, but much less friendly with humans. Even though **decompilers** are available for this job, they will likely not produce the exact original source code, due to optimizations applied at compile time. Moreover, variable names cannot be preserved in the compilation process, so the decompiled version will have unmeaningful variable names generated by the decompiler.

## Interpreted program

For the sake of convenience, portability, and many things else, it is sometimes helpful to run program source code without compiling. Doing this requires an **interpreter**, which, simply put, compiles and executes only one line of code at a time.
